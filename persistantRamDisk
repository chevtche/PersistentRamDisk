#!/bin/sh
### BEGIN INIT INFO
# Provides: persistantRamDisk
# Required-Start: $local_fs
# Required-Stop:
# X-Start-Before:	$syslog
# X-Stop-After:		$syslog
# X-Interactive:	yes
# Default-Start:	2 3 4 5
# Default-Stop:		0 1 6
# Short-Description:	Keeps /var/log and firefox profile in RAM
# Description: Moves the contents of /var/log and ~./.mozilla/firefox/*.profile
#              to RAM during boot and keeps it there until shutdown/reboot, when
#              it copies the contents back to permanent storage.
### END INIT INFO

# Version 1.0
# Author: Matteo Cortese <matteo_cortese@fastwebnet.it>
#         Grigori Chevtchenko <grigori.chevtchenko@epfl.ch>
#
# Inspired by ramlog by Jan Andrejkovic.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

PATH=/sbin:/bin:/usr/sbin:/usr/bin

NAME_RAMDISK=persistentRAMDISK
DESC_RAMDISK="Persistent RAMDisk manager"
LOCKFILE_RAMDISK=/var/lock/$NAME_RAMDISK.lock

NAME_LOG=transientlog
VARLOG=/var/log
SIZE_LOG=500M
MODE_LOG=0755

NAME_FIREFOX=firefoxProfile
FIREFOX=/home/greg/.mozilla/firefox/9vhs47bo.default
FIREFOX_CACHE_DIR=cache
SIZE_FIREFOX=1500M
MODE_FIREFOX=0700

# Read configuration variable file if it is present
[ -r /etc/default/$NAME_RAMDISK ] && . /etc/default/$NAME_RAMDISK

# Load the VERBOSE setting and other rcS variables
. /lib/init/vars.sh

# Define LSB log_* functions.
# Depend on lsb-base (>= 3.0-6) to ensure that this file is present.
. /lib/lsb/init-functions

if [ -z "$FIREFOXPERM" ]; then
	firefox_dir=`dirname $FIREFOX`
	firefox_name=`basename $FIREFOX`
	FIREFOXPERM="$firefox_dir/permanent$firefox_name"
	unset firefox_dir firefox_name
fi

if [ -z "$VARLOGPERM" ]; then
	varlog_dir=`dirname $VARLOG`
	varlog_name=`basename $VARLOG`
	VARLOGPERM="$varlog_dir/permanent$varlog_name"
	unset varlog_dir varlog_name
fi


do_start()
{
	# Return
	#   0 if persistentRAMDISK has been started
	#   1 if persistentRAMDISK was already running
	#   2 if persistentRAMDISK could not be started

	[ -f $LOCKFILE_RAMDISK ] && return 1

	# Check if I'm root
	[ `id -u` -eq 0 ] || return 2

	# If VARLOG or FIREFOX does not exist?
	[ -d $FIREFOX ] || return 2
        [ -d $VARLOG ] || return 2

	# VARLOGPERM or FIREFOXPERM either does not exist (first invocation)
	# or is empty (left from previous invocation).
	#
	[ -d $FIREFOXPERM ] || mkdir -p $FIREFOXPERM || return 2
        [ -d $VARLOGPERM ] || mkdir -p $VARLOGPERM || return 2

	# Mount a tmpfs over VARLOG and FIREFOX.
	# The mount will shadow the current contents of VARLOG and FIREFOX.
	# So, before, make a bind mount so that looking into VARLOGPERM and FIREFOXPERM
	# we'll see the current contents of VARLOG and FIREFOX, which
	# will not be available anymore as soon as we mount a tmpfs over it.
	#
	mount --bind $FIREFOX $FIREFOXPERM
        mount --bind $VARLOG $VARLOGPERM

        mount -t tmpfs -o nosuid,exec,nodev,mode=$MODE_FIREFOX,size=$SIZE_FIREFOX $NAME_FIREFOX $FIREFOX
        mount -t tmpfs -o nosuid,noexec,nodev,mode=$MODE_LOG,size=$SIZE_LOG $NAME_LOG $VARLOG

	if [ $? -eq 0 ]; then
		# Populate the FIREFOX's and VARLOG's tmpfs
		if ( cp -rfp $FIREFOXPERM -T $FIREFOX ) && ( cp -rfp $VARLOGPERM -T $VARLOG ); then
	                # Success!
                        touch $LOCKFILE_RAMDISK
                        echo [`date +"%Y-%m-%d %H:%M"`] firefox profile and /var/log/ RAMDisks Synched To RAM at Boot>> $VARLOG/$NAME_RAMDISK.log
                        return 0
		fi

		# Something went wrong... Rollback the mount
		umount -l $FIREFOX
                umount -l $VARLOG

	fi

	# Rollback the directory mangling
	umount $FIREFOXPERM
        umount $VARLOGPERM

	return 2
}

do_stop() {
	# Return
	#   0 if daemon has been stopped
	#   1 if daemon was already stopped
	#   2 if daemon could not be stopped
	#   other if a failure occurred

	[ -f $LOCKFILE_RAMDISK ] || return 1

	# Check if I am root
	[ `id -u` -eq 0 ] || return 2

	# Merge back to permanent storage
        rsync -a --quiet --delete --recursive --force --exclude $FIREFOX_CACHE_DIR $FIREFOX/ $FIREFOXPERM/
        rsync -a --quiet --delete --recursive --force $VARLOG/ $VARLOGPERM/
        echo [`date +"%Y-%m-%d %H:%M"`] firefox profile and /var/log/ RAMDisks Synched To HDD at Shutdown>> $VARLOGPERM/$NAME_RAMDISK.log

	# The following cannot fail... or can it?
	umount -l $FIREFOX
	umount -l $FIREFOXPERM
        umount -l $VARLOG
	umount -l $VARLOGPERM
	rm -f $LOCKFILE_RAMDISK
	return 0
}

do_reload() {
	# Return
	#   0 if persistentRAMDISK has been reloaded
	#   1 if persistentRAMDISK was not running
	#   2 if persistentRAMDISK could not be reloaded

	[ -f $LOCKFILE_RAMDISK ] || return 1

	# Check if I am root
	[ `id -u` -eq 0 ] || return 2

	# Merge back to permanent storage
        rsync -a --quiet --delete --recursive --force --exclude $FIREFOX_CACHE_DIR $FIREFOX/ $FIREFOXPERM/
        rsync -a --quiet --delete --recursive --force $VARLOG/ $VARLOGPERM/
        echo [`date +"%Y-%m-%d %H:%M"`] firefox profile and /var/log/ RAMDisks Synched Together>> $VARLOG/$NAME_RAMDISK.log
        echo [`date +"%Y-%m-%d %H:%M"`] firefox profile and /var/log/ RAMDisks Synched Together>> $VARLOGPERM/$NAME_RAMDISK.log

	touch $LOCKFILE_RAMDISK
	return 0
}





case "$1" in
  start)
	[ "$VERBOSE" != no ] && log_daemon_msg "Starting $DESC_RAMDISK" "$NAME_RAMDISK"
	do_start
	case "$?" in
		0|1) [ "$VERBOSE" != no ] && log_end_msg 0 ;;
		2) [ "$VERBOSE" != no ] && log_end_msg 1 ;;
	esac
	;;
  stop)
	[ "$VERBOSE" != no ] && log_daemon_msg "Stopping $DESC_RAMDISK" "$NAME_RAMDISK"
	do_stop
	case "$?" in
		0|1) [ "$VERBOSE" != no ] && log_end_msg 0 ;;
		2) [ "$VERBOSE" != no ] && log_end_msg 1 ;;
	esac
	;;
  status)
  	if [ -f $LOCKFILE_RAMDISK ]; then
		echo "$DESC_RAMDISK is running"
	else
		echo "$DESC_RAMDISK is stopped"
		exit 1
	fi
	;;
  reload)
	log_daemon_msg "Reloading $DESC_RAMDISK" "$NAME_RAMDISK"
	do_reload
	log_end_msg $?
	;;
  *)
	echo "Usage: $0 {start|stop|status|reload}" >&2
	exit 3
	;;
esac
